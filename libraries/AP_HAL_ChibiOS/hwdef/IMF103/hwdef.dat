# hw definition file for processing by chibios_hwdef.py
# for FMUv3 hardware (ie. for Pixhawk1, Pixhawk2 cube, XUAV2.1 etc)

# This hwdef.dat file contains a lot of comments so it can act as a
# reference for developers adding new boards.

# The hwdef.dat file defines all the hardware peripherals and pins for
# a port of ArduPilot to a board using the ChibiOS HAL. You should be
# able to write the hwdef.dat file for a new board with just the
# schematic for the board.

# This file is processed by chibios_hwdef.py to create hwdef.h for
# this board. You may find it useful to run chibios_hwdef.py manually
# when building this file for a new board. The resulting hwdef.h file
# is formatted to make it quite readable. It is strongly suggested
# that you read the resulting hwdef.h file when porting to a new board
# to make sure it has resulted in what you want.

# You should read this file in conjunction with the schematic for your
# board, the datasheet for the MCU for your board and the python
# tables file that we have extracted from the datasheet for your
# MCU. The python tables file is particularly important, so if you
# haven't seen it before go and look at it now. For the STM32F427 it
# it called STM32F427xx.py and it is in the hwdef/script/ directory
# inside the HAL_ChibiOS directory. That file tells you what each pin
# can do (the alternate functions table) and what DMA channels can be
# used for each peripheral type. The alternative functions table is
# particularly useful when doing a new hwdef.dat file as you can work
# out peripheral numbers given a port/pin name.

# We need to start off by saying what main CPU is on the board. There
# are two CPU identifiers that you need to specify. The first is the
# ChibiOS MCU type. So far we only support STM32F4xx for all STM32F4
# board types. In the future we will add F7 and other MCU types
# The second string needs to match the name of a config file in the
# libraries/AP_HAL_ChibiOS/hwdef/script directory. In this case we are
# using a F427 MCU, so we select STM32F427xx to match the
# STM32F427xx.py file in the script directory. If you are supporting a
# board type that doesn't have a python hardware database file yet
# then you will need to create one. There are scripts in the scripts
# directory to help with that by parsing the STM32 datasheets to
# extract the required DMA and alternate function tables.

# MCU class and specific type
MCU STM32F4xx STM32F427xx

# We set a specific HAL_BOARD_SUBTYPE, allowing for custom config in
# drivers. For this to be used the subtype needs to be added to
# AP_HAL/AP_HAL_Boards.h as well.
# define CONFIG_HAL_BOARD_SUBTYPE HAL_BOARD_SUBTYPE_CHIBIOS_FMUV3

# Now we need to specify the APJ_BOARD_ID. This is the ID that the
# bootloader presents to GCS software so it knows if this firmware is
# suitable for the board. Please see
# https://github.com/ArduPilot/Bootloader/blob/master/hw_config.h for
# a list of current board IDs. If you add a new board type then please
# get it added to that repository so we don't get conflicts.

# Note that APJ is "ArduPilot JSON Firmware Format".

# board ID for firmware load
APJ_BOARD_ID 9

# crystal frequency
OSCILLATOR_HZ 8000000

# define HAL_CUSTOM_CLOCK_TREE
# define STM32_PLLM_VALUE 8
# define STM32_PLLN_VALUE 72
# define STM32_PLLP_VALUE 2
# define STM32_PLLQ_VALUE 7

# ChibiOS system timer
STM32_ST_USE_TIMER 5

# flash size
FLASH_SIZE_KB 128

STDOUT_SERIAL SD0
STDOUT_BAUDRATE 115200

# USB setup
USB_STRING_MANUFACTURER "ArduPilot"
USB_STRING_PRODUCT "%BOARD%"

# order of I2C buses
I2C_ORDER I2C2

# The normal usage of this ordering is:
# 1) SERIAL0: console (primary mavlink, usually USB)
# 2) SERIAL1: telem1
# 3) SERIAL2: telem2
# 4) SERIAL3: primary GPS
# 5) SERIAL4: GPS2
# 6) SERIAL5: extra UART (usually RTOS debug console)
# ?) EMPTY

# order of UARTs (and USB)
SERIAL_ORDER OTG1 EMPTY EMPTY USART2

# USART2 serial GPS
PA2 USART2_TX USART2
PA3 USART2_RX USART2

# Now the first SPI bus. At minimum you need SCK, MISO and MOSI pin
PA5 SPI1_SCK SPI1
PA6 SPI1_MISO SPI1
PA7 SPI1_MOSI SPI1

# This defines an output pin which will default to output LOW. It is a
# pin that enables peripheral power on this board.
# PA8 VDD_5V_PERIPH_EN OUTPUT LOW

# Now we define the pins that USB is connected on.
PA11 OTG_FS_DM OTG1
PA12 OTG_FS_DP OTG1

# Now the first I2C bus. The pin speeds are automatically setup
# correctly, but can be overridden here if needed.
PB10 I2C3_SCL I2C2
PB11 I2C3_SDA I2C2

# PB10 BMI088_A_CS CS
# PB11 BMI088_G_CS CS

# SBUS
# PA0 UART4_TX UART4
# PA1 UART4_RX UART4

# Telemetry
# PC6 USART6_TX USART6
# PC7 USART6_RX USART6

# Now we start defining some PWM pins. We also map these pins to GPIO
# values, so users can set BRD_PWM_COUNT to choose how many of the PWM
# outputs on the primary MCU are setup as PWM and how many as
# GPIOs. To match HAL_PX4 we number the GPIOs for the PWM outputs
# starting at 50.
PB6 TIM4_CH1 TIM2 PWM(1) GPIO(50)
PB7 TIM4_CH2 TIM2 PWM(2) GPIO(51)
PB8 TIM4_CH3 TIM3 PWM(3) GPIO(52)
PB9 TIM4_CH4 TIM3 PWM(4) GPIO(53)

define BOARD_PWM_COUNT_DEFAULT 4

# Now the SPI device table. This table creates all accessible SPI
# devices, giving the name of the device (which is used by device
# drivers to open the device), plus which SPI bus it it on, what
# device ID will be used (which controls the IDs used in parameters
# such as COMPASS_DEV_ID, so we can detect when the list of devices
# changes between reboots for calibration purposes), the SPI mode to
# use, and the low and high speed settings for the device.

# You can define more SPI devices than you actually have, to allow for
# flexibility in board setup, and the driver code can probe to see
# which are responding.

# The DEVID values and device names are chosen to match the PX4 port
# of ArduPilot so users don't need to re-do their accel and compass
# calibrations when moving to ChibiOS.

# SPIDEV ms5611         SPI1 DEVID3  BARO_CS      MODE3 20*MHZ 20*MHZ
# SPIDEV ms5611_ext     SPI4 DEVID2  BARO_EXT_CS  MODE3 20*MHZ 20*MHZ
# SPIDEV mpu6000        SPI1 DEVID4  MPU_CS       MODE3  2*MHZ  8*MHZ
# SPIDEV icm20608-am    SPI1 DEVID2  ACCEL_EXT_CS MODE3  4*MHZ  8*MHZ
# SPIDEV mpu9250        SPI1 DEVID4  MPU_CS       MODE3  4*MHZ  8*MHZ
# SPIDEV mpu9250_ext    SPI4 DEVID1  MPU_EXT_CS   MODE3  4*MHZ  8*MHZ
# SPIDEV icm20948       SPI1 DEVID4  MPU_CS       MODE3  4*MHZ  8*MHZ
# SPIDEV icm20948_ext   SPI4 DEVID1  MPU_EXT_CS   MODE3  4*MHZ  8*MHZ
# SPIDEV hmc5843        SPI1 DEVID5  MAG_CS       MODE3 11*MHZ 11*MHZ
# SPIDEV lsm9ds0_g      SPI1 DEVID1  GYRO_EXT_CS  MODE3 11*MHZ 11*MHZ
# SPIDEV lsm9ds0_am     SPI1 DEVID2  ACCEL_EXT_CS MODE3 11*MHZ 11*MHZ
# SPIDEV lsm9ds0_ext_g  SPI4 DEVID4  GYRO_EXT_CS  MODE3 11*MHZ 11*MHZ
# SPIDEV lsm9ds0_ext_am SPI4 DEVID3  ACCEL_EXT_CS MODE3 11*MHZ 11*MHZ
# SPIDEV icm20602_ext   SPI4 DEVID4  GYRO_EXT_CS  MODE3  4*MHZ  8*MHZ
# SPIDEV ramtron        SPI2 DEVID10 FRAM_CS      MODE3  8*MHZ  8*MHZ
# SPIDEV external0m0    SPI4 DEVID5  MPU_EXT_CS   MODE0  2*MHZ  2*MHZ
# SPIDEV external0m1    SPI4 DEVID5  MPU_EXT_CS   MODE1  2*MHZ  2*MHZ
# SPIDEV external0m2    SPI4 DEVID5  MPU_EXT_CS   MODE2  2*MHZ  2*MHZ
# SPIDEV external0m3    SPI4 DEVID5  MPU_EXT_CS   MODE3  2*MHZ  2*MHZ
# SPIDEV pixartPC15     SPI4 DEVID13 ACCEL_EXT_CS MODE3  2*MHZ  2*MHZ

# SPIDEV bmi088_a SPI1 DEVID2 BMI088_A_CS MODE3 2*MHZ 2*MHZ
# SPIDEV bmi088_g SPI1 DEVID3 BMI088_G_CS MODE3 2*MHZ 2*MHZ

# IMU BMI088 SPI:bmi088_a SPI:bmi088_g ROTATION_NONE
# IMU Invensense I2C:0:0x68 ROTATION_ROLL_180

# Now some commented out SPI device names which can be used by
# developers to test that the clock calculations are right for a
# bus. This is used in conjunction with the mavproxy devop module.

# for SPI clock testing
# SPIDEV clock500 SPI4 DEVID5  MPU_EXT_CS   MODE0  500*KHZ 500*KHZ # gives 329KHz
# SPIDEV clock1   SPI4 DEVID5  MPU_EXT_CS   MODE0  1*MHZ 1*MHZ     # gives 657kHz
# SPIDEV clock2   SPI4 DEVID5  MPU_EXT_CS   MODE0  2*MHZ 2*MHZ     # gives 1.3MHz
# SPIDEV clock4   SPI4 DEVID5  MPU_EXT_CS   MODE0  4*MHZ 4*MHZ     # gives 2.6MHz
# SPIDEV clock8   SPI4 DEVID5  MPU_EXT_CS   MODE0  8*MHZ 8*MHZ     # gives 5.5MHz
# SPIDEV clock16  SPI4 DEVID5  MPU_EXT_CS   MODE0  16*MHZ 16*MHZ   # gives 10.6MHz

define ALLOW_ARM_NO_COMPASS
define HAL_COMPASS_DEFAULT HAL_COMPASS_NONE
# define HAL_PROBE_EXTERNAL_I2C_COMPASSES
# define HAL_I2C_INTERNAL_MASK 0
# define HAL_COMPASS_AUTO_ROT_DEFAULT 2

define HAL_INS_DEFAULT HAL_INS_NONE
define HAL_BARO_DEFAULT HAL_BARO_NONE
define HAL_BARO_ALLOW_INIT_NO_BARO

# This adds a C define which sets up the ArduPilot architecture
# define. Any line starting with 'define' is copied literally as
# a #define in the hwdef.h header.
# define HAL_CHIBIOS_ARCH_FMUV3 1

# Nnow some defines for logging and terrain data files.
# define HAL_BOARD_LOG_DIRECTORY "/APM/LOGS"
# define HAL_BOARD_TERRAIN_DIRECTORY "/APM/TERRAIN"

# We need to tell HAL_ChibiOS/Storage.cpp how much storage is
# available (in bytes).
define HAL_STORAGE_SIZE 15360
define STORAGE_FLASH_PAGE 1

# reserve 32k for bootloader and 32k for flash storage
FLASH_RESERVE_START_KB 64

# allow to have have a dedicated safety switch pin
define HAL_HAVE_SAFETY_SWITCH 0

define HAL_HAVE_BOARD_VOLTAGE 0

# Setup for the possibility of an IMU heater since the pixhawk2 cube has
# an IMU heater.
define HAL_HAVE_IMU_HEATER 0

# Enable FAT filesystem support (needs a microSD defined via SDIO).
# define HAL_OS_FATFS_IO 1

# This defines the default maximum clock on I2C devices.
define HAL_I2C_MAX_CLOCK 400000

# We can't share the IO UART (USART6).
# DMA_NOSHARE USART6_TX ADC1
# DMA_PRIORITY USART6 * SPI*

# Don't share SBUS input
# DMA_NOSHARE SPI* UART4_RX
# DMA_PRIORITY SPI1 UART4

# List of files to put in ROMFS. For fmuv3 we need an IO firmware so
# we can automatically update the IOMCU firmware on boot. The format
# is "ROMFS ROMFS-filename source-filename". Paths are relative to the
# ardupilot root.
# ROMFS io_firmware.bin Tools/IO_Firmware/iofirmware_lowpolh.bin

# no ADC pins
define HAL_USE_ADC FALSE
